<div class="txtcont">
													
													
													<p>(defun dummy()&nbsp;<br>&nbsp;&nbsp;&nbsp;(list '("first"&nbsp;. 1)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'("second"&nbsp;.&nbsp; 2)))&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;如果认为在任何时候&nbsp;(dummy)&nbsp;都会返回&nbsp;<br>&nbsp;(("first"&nbsp;. 1 )&nbsp;("second"&nbsp;. 2))&nbsp;&nbsp;<br>&nbsp;那你就错了。&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;看下面的例子&nbsp;<br>&nbsp;(let*&nbsp;((m (dummy))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;;&nbsp;----给n赋&nbsp;一个nil值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m1 (assoc&nbsp;"first" m)))&nbsp;<br>&nbsp;&nbsp;&nbsp;(setcdr m1 100)&nbsp;<br>&nbsp;&nbsp;&nbsp;(setq n (dummy))&nbsp;<br>&nbsp;&nbsp;&nbsp;(message "\n%S&nbsp;%S&nbsp;%S\n" m m1 n))&nbsp;<br>&nbsp;&nbsp;<br> n 的值居然是&nbsp;(("first"&nbsp;. 100)&nbsp;("second"&nbsp;. 2))&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;只有这样写&nbsp;<br>&nbsp;(defun dummy()&nbsp;<br>&nbsp;&nbsp;&nbsp;(list (cons&nbsp;"first"&nbsp; 1)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons "second"&nbsp; 2)))&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;(dummy)&nbsp;才会永远返回&nbsp;(("first"&nbsp;. 1)&nbsp;("second"&nbsp;. 2))&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;这是一个有意思的现象。&nbsp;<br>&nbsp;估计是 elisp 为了优化，quote&nbsp;产生的对象是返回的是一个类似与引用&nbsp;<br>&nbsp;的东西。&nbsp;任何 side-effect 的 set*&nbsp;函数都可以修改这个一个值。&nbsp;<br></p> 
<p><br></p> 
<p>那合理的解释是：函数的返回值跟函数本身可能根本就是一回事情。修改函数的返回值有可能导致函数本身被修改？<br></p> 
<p><br></p> 
<p>function is nothing more than a list.&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;所谓函数，本质上也是一个数据，就是 list <br>&nbsp;(lambda ()&nbsp;'(1 2 4)&nbsp;也就是一个简单的list &nbsp;<br>&nbsp;函数的返回值也就是 list 中的一部分的 evaluation.&nbsp;<br>&nbsp;只不过这个特殊的例子，eval 之后，得到的是函数本身的&nbsp;<br>&nbsp;一部分，&nbsp;'(1 2 4)&nbsp;,&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;修改返回值，也就是修改原来 list （函数）中的一部分。&nbsp;<br></p> 
<p><br></p> 
<p>Common Lisp 里也有同样的问题。Paul Graham 在《On Lisp》一书里给出一个规则：&nbsp;<br>&nbsp;"functions shouldn't return quoted lists."&nbsp;并且指出除了宏展开函数以外，其他&nbsp;<br>&nbsp;函数返回值中含有引用的列表都可能不安全。(具体位置在该书的 3.3 节)&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;下列书中的例子更加明显：&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;(defun exclaim (expression)&nbsp;<br>&nbsp;&nbsp;&nbsp;(append expression '(oh my)))&nbsp;<br>&nbsp;&nbsp;<br> Then any later destructive modification of the return value <br>&nbsp;&nbsp;<br>&nbsp;&gt;&nbsp;(exclaim '(lions and tigers and bears))&nbsp;<br>&nbsp;(LIONS AND TIGERS AND BEARS OH MY)&nbsp;<br>&nbsp;&gt;&nbsp;(nconc *&nbsp;'(goodness))&nbsp;&nbsp;&nbsp;;---concatenate&nbsp;连在一起,改变了函数中的'(oh my)<br>&nbsp;(LIONS AND TIGERS AND BEARS OH MY GOODNESS)&nbsp;<br>&nbsp;&nbsp;<br> could alter the list within the function:&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;&gt;&nbsp;(exclaim '(fixnums and bignums and floats))&nbsp;<br>&nbsp;(FIXNUMS AND BIGNUMS AND FLOATS OH MY GOODNESS)&nbsp;<br>&nbsp;&nbsp;<br> To make exclaim proof against such problems, it should be written:&nbsp;<br>&nbsp;&nbsp;<br>&nbsp;(defun exclaim (expression)&nbsp;<br>&nbsp;&nbsp;&nbsp;(append expression (list&nbsp;'oh&nbsp;'my)))&nbsp;<br>&nbsp;&nbsp;<br><br></p> 
<p><br></p>
													
												</div>